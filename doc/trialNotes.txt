18/01/2025
Trial A15 run to round 1650, solved most of the fixed
rules. Performance otherwise about the same.

Trial A16 includes 3 new rules and a fix.

16/01/2025
Trial A14 ran to 3600 rounds and achieved about the same
result trial A13.

Trial A15 Commenced with fixes to loadMem and sample in/out
rules.

11/01/2025
Trail A13 run until 3000 rounds. Results the same as for
A12, but with 2 new and 2 lost rules.

Commenced Trial A14 with additional rules (counts etc).
Will run to the trial to 3200 rounds to take account of
additional rules. This follows the policy of extending
the mesh of solutions.

07/01/2025
Ended Trial A12 after 2600 rounds (9 loops), some rules
gained some lost, slightly more losses (2).

Commenced Trial A13 with 3 rounds per rule and adjustments
to divide by first param and load mem (dual scoring).
Added rule count odd/even in fives. The aim is to provide
a probabilistically shallow network of code interrelated
rules, so that they form a "probabilistically linked meshwork".

03/01/2026
Ended Trial A11 after 2500 rounds, Power first Param 2 completed
after 18 loops. Other rules completed as per A10.

For Trial A12, the rounds per rule is increased from 2 to 4,
the divide template is removed, the sampleIn sampleOut rules
are fixed and weightedMonoclonalByteBreed is adjusted to allow
for more insertions and deletions.

30/12/2025
Ended trial A10 after 1650 rounds. About three rules better
than A09.

Commence trial A11 - adjusted weightedMonoclonalByteBreed.
Fixed sample-in sample-out rules. Added add/subtract first
sample in/out rules.

28/12/2025
Trial A10 commenced including code weighted breeding, in the
hope of structured template-like entities forming.

26/12/2025
Trial A09 completed about 6 more rules and 2 less than A08.

22/12/2025
Trail A08 run for 1600 rounds did slightly better than trial
A07.

New trial A09 start from scratch with fix to bestsStore
and subOptRuleMemSpaces.

20/12/2025
Trial A07 completed rather fewer rules than with the use
of carried-over subsolutions.

Begin new trial A08, at the other extreme, with rounds per
rule set to 2 and full carry-over (10%).

16/12/2025
Result at 2500 rounds is not an improvement on A02.

Presumably, the recycled partial solutions are more
of a hindrance than a help in solution finding.

Suspend the partial solutions feature and re-run the trial
(A07).

12/12/2025
Fixed problem with getCurrentMaxScore, preceding few trials
invalid since after A02.

Restarted trial from scratch (A06).

11/12/2025
Logged previous trial as CompletionsLogA05.txt.

Fixed rules Outputs Different Sum to First and Cube Roots.
Restarted trial from scratch.

05/12/2025
Restarted trial from scratch with adjustment to cube root 
rule. Aim is to check-out the degree of random variance in
rule solving in the current set-up.

03/12/2025
In 2500 rounds completed fewer rules than the previous
trial, notably missing out the output series rules.

However a few rules were completed that were not
completed in the previous trial, notably Convert ASCII
Numbers 1.

Trials ended until further rules added or new strategy
considered.

29/11/2025
Last trial completed just over half the rules in 2500 rounds.
Logged to CompletionsLogA02.txt

New trial includes additional rules, start from scratch.

26/11/2025
After about 2800 rounds (14 rule loops) the trial had
completed a similar number of rules as the 90 Rounds
per rule maximum.

Clear the tables and restart the trial with the number of
rounds per rule increased from 4 to 6.

Begin study of static templates

24/11/2025
After 1840 rounds (about 9 rule loops) fewer rules had
been completed than in passes of 60 or 90 rounds per
rule (6000 or 9000 rounds), so the result is inconclusive.
Likely it would be best to await the completion of say 
5000 rounds, to make a just comparison.

22/11/2025
Changed the IOC A, (C) instruction to be limited to the
first three bytes of correct output as a sampler.

Retart trial with database cleared.

21/11/2025
Changed rule handling to cycle through the rules in a short number
of rounds each (4), saving the best result for re-use in this and
other rules. When the end of the ruleset is reached, restarts at the
first non-completed rule.

Changed rule LISC A to IOC A, (C) which compares a required output
to a set output for a correct match.

Restarted trial from scratch with no recorded data.

This trial found a generic "cheat" by scanning to correct values
using the IOC A, (C) instruction.

19/11/2025
Picked-up where trial left-off at divide by first param.
Included the seed for divide by first param as a template.
This rule is now solved.

The aim is to build-up a set of machine and human generated
solutions which the system can use to more likely find
solutions to novel problems.

This approach is still deemed too slow and cumbersome and prone 
to get trapped in sub-optimal solutions.

For a possible remedy see WorkedExamples - Short Sampling

09/10/2025
Halt trial at nth Prime. No significant gains this trial.

Modify LISC A to include score on number of hits. Add
insDistribution instructions to the divide rules.

Restart trial continuing with seed.


03/10/2025
Trial completed adding seven rule completions from the
previous trial.

Start new trial with additional rules, increase the number
of rounds per rule sequence num to 90 from 60.

22/09/2025
Trial successfully completed about 50% of the rules.
Recommenced using carried-over seed and the reduced
random instruction set. Also included are the rules
for second and third roots.

Now logging final results.

12/09/2025

Trial succesfully completed the subtract First Param Second 
Times rule, which is generally missed.

Added the rules Add Sum of First and Second Params and
Sub Sum of First and Second Params.

Reduced the max rounds per rule from 150 to 60 and restarted
the trial using the current seed.

10/09/2025
Current run fails the sample data usage rules

09/09/2025
The current trial produces no significant at the halfway
stage. Division is still incomplete.

Plan is to introduce an instruction to permit the entity
programs to inspect an interim score in order to allow
a certain amount of analytical logic in the entities.

Score inspection rule added. Trials started from scratch.

05/09/2025
The earlier result proved to be spurious as there was an
error in the rulesets code. Trial restarted, preserving
seed. Will probably take 10 days to reach a conclusion
about current performance.

03/09/2025
Having added four or five new rules and re-run the
complete trial over two and half complete passes, the 
system now solves the divide problems in addition to the
simpler problems.

Trials to continue to completion with the addition of rules
prior to each complete pass.


10/08/2025
Full trial completed to final rule. Attains a success rate
of about 50%, primarily of the simpler rules.

Restarted trial with seed preserved from the complete trial
to see whether the seed allows the completion of more rules.

22/07/2025
Trial restarted from scratch after fix to
number of rounds threshold and clearance of
seedbedData.

19/07/2025
Trial restarted with existing seed rules.

11/07/2025
Trial failed on sampleInMinusSampleOut and 
multiplyByFirstParam3

Adjusted to seedbed to individual entity sets.
Increased the clearance round to 40. Reduced
the maximum number of trail rounds for a rule
from 320 to 150.
Restarted trial from scratch.

09/07/2025
Restarted trial from scratch with shufflesets 
modified to 1 in 8 rounds.


07/07/2025
Trial Reached moduloFirstParam7 on round 1071
reaching 45.5/57 after 144 rounds.

Failed on moduloFirstParam6 and sampleInMinusSampleOut.

Reversed the order of modulo6/7

Removed the seedRule and template inclusions to seedbed
only.

Still failed on sampleInMinusSampleOut

05/07/2025
Trial reached moduloFirstParam7 on round 1248,
reaching 44/57 after 200 rounds;
having failed SampleInMinusSampleOut and
moduloFirstParam6.

Adjusted the seedbed to 3 beds and the trial
time to 25 rounds.

Also modified shufflesets to sample only upto
but not including the seedbed.


03/07/2025
Trial restarted from scratch with fix to seed rules and 
log getting out of step.

02/07/2025
Trial ended with problem with seedRuleSeedbedLog.
Possibly database fault.

Restarted from scratch.

01/07/2025
Trial progressed to DivisibleByFirstParam after
47 rounds using existing seed, but then reached 
43.4/57 after 270 rounds. This trial was voided by 
the fact that arrays derived from the cleared tables 
were not cleared.

Add rules selectLess and selectGreaterThanFirstParam,
to introduce the notion of selection of parameters.

Restarted trial.

30/06/2025
Added seedbed handling to code to allow for better
transference of learned procedures.

Trial restarted from scratch.

24/06/2025

DivisibleByFirstParam reached 44.3/57 before
ending.

Now adding seed bed procedures for seed templates
and seed rules.

23/06/2025

Added insDistribution to DivisibleByFirstParam
restarted trial at that rule.

22/06/2025

Trial reached DivisibleByFirstParam after 426 rounds.
Modulo 6 and 7 were completed in 27 and 2 rounds respectively.
This strongly indicates the value of lead-up rules such as
SubtractFirstParamSecondTimes

Currently 42.1/57 on DivisibleByFirstParam after 60 rounds.

21/06/2025

Modulo 6 failed.
Modulo 7 reached 44.7/53 after 270 rounds.

Clear tables and restart with new rules

20/06/2025
Retrial started from scratch reached moduloFirstParam6
before getting stuck. Took 332 rounds to reach that point.

Will now add rules:
    andFirstParam
    orFirstParam
    andAdjacentParams
    orAdjacentParams
    reverseTripletOrder
    reverseParamsOrder
    SubtractFirstParamSecondTimes
    
The general idea here is to give the system as wide a range
of problems as feasible, to see whether it can develop any
general patterning capability.

19/06/2025
Divisible by first param failed at 39.2/53

Not Divisible by first param has score 41.9/53
after 88 rounds.

Will wait and see whether the not divisible rule
can be fed-back to the divisible by rule

Not divisible by first param also failed.

Change of course:
Introduced the helper rule generalInsDistribution and
extended the number of IC instructions to 8000.
This allows for the possibility of analytical code
to develop, alongside rule solutions.

Trial restarted from scratch.

18/06/2025

modulo first param 6 failed but
modulo first param 7 passed in 6 rounds

Have restarted at modulo first param 6, hoping
that the solution to 7 will help.

Modulo 6 completed in one round.

Divisible by first param 38.5/53 at 70 rounds.

17/06/2025

Failed modulo first param 6, currently doing modulo
first param 7

Aim is to use templates and fragments to make rules work.

Modulo first param 6 and 7 failed, so the task is to get
them working via the fragment and template methods.


16/06/2025

Series of series 1 failed at 46.3/49 despite the
use of the template. We note that the program
produced bore little relation to the template logically
but looked as though it may have originated from it.

Modified template and restarted.

Since the template was more or less the solution, this resolved
in 4 rounds.

15/06/2025
SeriesOfSeries2 Completed after 259 rounds.

SeriesOfSeries3 at 41.5/49 after 130 rounds.

SeriesOfSeries3 still failed, having reached 42.2/49.

Template introduced on development system.

Replace Chance on monoclonalInsBreed set to 0.6 from 0.5

Restarted Trial with clear database, to see how series of series
fares. The aim to see what is necessary without resorting to the
seed program as a solution.

14/06/2025

Having re-run the trial from scratch with seriesOfSeries
having insDistribution set with 6 instructions, we find
that the seriesOfSeries1 reaches only 35/49 after 280
rounds. Generally this passes by about round 170.

Adjusted insDistribution to following:

    insDistribution: [
        {
            ins: "LDI A, (C)",
            countOpt: 3,
            scanStart: 0,
            scanEnd: 30
        },
        {
            ins: "INC C",
            countOpt: 3,
            scanStart: 0,
            scanEnd: 40
        },
        {
            ins: "SWP A, B",
            countOpt: 1,
            scanStart: 0,
            scanEnd: 20
        }
    ],

SeriesOfSeries1 completed after 132 rounds.
SeriesOfSeries2 reached 45.5/49 after 170 rounds.

10/06/2025

Restarted the trials from scratch to see which rules 
passed and which did not. The usual rules failed.

Currently attempting to get seriesOfSeries3 working
with fragments.

Next-up skip the earlier seriesOfSeries rules, because
it is possible that the seed from these misdirects the
development of seriesOfSeries3.

29/05/2025
Trial stuck on ASCIIParams2, have included fragments
without additional success.

Currently deciding whether to continue with the project 
by continuing to add rules with the aim of it developing
a fragment library.

26/05/2025
Seed program for op adjacent params worked ok. So
after a time the trial system proceeded to ASCIIParams 1,
which it completed in 208 rounds.

Adjusted the ASCII rules to take explicitly declared strings.
Re-loaded, now on ASCIIParams 2.

22/05/2025
Stuck on op multiply adjacent params. Added multiplier
fragment.

Op Multiply adajacent params was stuck at 20.7/26 after
360 rounds, so used seed program.

21/05/2025
Added Template for opAdjacentParams, add completed
after 3 rounds, subtract after 160 rounds.

20/05/2025
Stuck at multiplyAdjacentParams, tried templates and
fragments without success. Seeded solution.

18/05/2025

sortTriplets had not completed after 580 rounds. (30/38)

Add part of the sort solution as a fragment. Completed
after 380 rounds.


17/05/2025

find Number Triplets completed after 390 rounds.

sortTriplets had not completed after 800 rounds. (32/38)

Added fragment for sortTriplets and amended rule to
include insDistribution.

16/05/2025

After the addition of some new fragments and a fix to the
insDistribution of the getNumbersBetweenFirstTwo rule, the
trial completed after 120 rounds and went on to complete
as far as rule findNumbers after 440 rounds.

Currently on findNumbers for 100 rounds. findNumbers
reached 30/38 after 500 rounds.

Restarted trial at findNumbers with additional fragments.

findNumbers template worked within two rounds

Now proceeded to findNumberTriplets

29.9/38 after 60 rounds

15/05/2025

Trial on getNumbersBetweenFirstTwo reached 24.3/28 after
560 rounds.

Added JRNC/C/Z to insDistribution for the rule and added
fragments for accessing the first two input bytes.

Got to 22/28 after 380 rounds.

Added a template for the rule and restarted.

14/05/2025
Modified the code fragments set and increased the frequency of
selecting them in monoclonalInsBreed. Left the trial to run
with these fragments available for about 6 hours.

The highest result achieved on the trial was 21.96/26, there
was no use of CMP A, B in the highest scoring solution, although
SUB A, B did appear in the code sequence.

Next trial is to start at the getNumbersLessThanFirst rule from
scratch, to see how it progresses with the fragments available.
This trial reached 20.4/26 after 216 rounds

Increase the clearance round to 25 (from 20) and the restart proportion 
to 0.7 (from 0.6). Also increased the insDistribution score to 2.

Solved getNumbersLessThanFirst in 3 rounds

Part of the reason why this rule may have been failing is that the solution
values already exist in the input data and therefore have a higher
chance of appearing in the output, blocking the pathways to a 
correct solution. We might be able to allow for this with a special
type of scoring applied to this type of rule.

Score at 22.8/28 on getNumbersBetweenFirstAndSecond after 48 rounds.

12/05/2025
Seeded getNumbersGreaterThanFirst.

The rule getNumbersLessThanFirst was still stuck on
the scoring system after 200 rounds, despite the presence
of the getNumbersGreaterThanFirst seed. This is basically
because the scoring is primarily output based not code
based. See an analysis of this in WorkedExamples.txt

Still only 20.4/26 after 400 rounds on getNumbersGreaterThanFirst.
Adjusted set shuffle to 2 to encourage more variation of solutions.

11/05/2025
Added template seeding to system. Resumed trial on
getNumbersGreaterThanFirst. Reached 23/26 after 600
rounds.

10/05/2025
Trial system failed to complete rule getNumbersGreaterThanFirst
after 600 rounds, added rule modification insDistribution: CMP A, B; JRC.
Changed the order of rules so that rule greaterThanFirstParam and
compareFirstParam precede. 

09/05/2025
Trial system failed to complete rule getNumbersGreaterThanFirst
after 600 round, added rule modification insDistribution: CMP A, B 

Trial on getNumbersGreaterThanFirst still failed, so have add the
option to start at a specified rule and restarted the rule from
scratch with the insDistribution: CMP A, B set.


08/05/2025
Trial completed divide by first param 2 after 660 rounds.

Changed the number of best sets to 72 and the numCPUs on
the trial machine to 6.

Seeded divide by first param 3 after 350 rounds.

07/05/2025
Trial has run without seeding as far as moduloFirstParam7,
755 rounds so far. Modulo7 has required about 100 rounds
to reach 36/49, suggesting that the earlier modulo solutions were
not strictly algorithmic. Perhaps 4 execution cycle examples for
a rule are necessary (as in the case of modulo 7)?

Added the Extract odd/even rules.

Seeded the trial with modulo first param.

06/05/2025
Recommenced trial from scratch, including SR A and SL A 
instructions.


05/05/2025
Trial has reached rule findNumbers which
it has trialed for 140 rounds.

Stuck on findNumbers at 25/36. Modified the findNumbers
rule to include insDistribution for CMP A, B
Re-run at round 3948

04/05/2025
Inserted seed
    greaterOfAdjacentParams

02/05/2025
Inserted one seed program
    seriesOfSeries
Trial has now reached moduloFirstParam6 at round 908.

Seeded moduloFirstParam at about round 1250

Introduced a new rule findNumbers

Seeded divideByFirstParam

01/05/2025
AICode system set-up on the new multi-core trial computer
first speed test, 

    sqlite, serial: 25 rounds per hour (25% gain)
    sqlite, parallel: 42 rounds per hour (100% gain)

With the trial on the new system sampleOutGreaterThanSampleIn
was solved in 137 rounds. This is the first time that that
rule has been successfully solved. Need to verify code.

The sampleInMinusSampleOut rule took 180 rounds to complete.


30/05/2025
The trial on the windows laptop reached 29/36 on
sort triplets after 2361 rounds. Upto this point
the only seeded programs were
    sampleOutGreaterThanSampleIn
    seriesOfSeries
    divideByFirstParam

29/05/2025
Occasional crashes with promises problem with sqlite, 
could try increasing the timeout for a fresh write 
attempt.

28/05/2025
Trial on windows laptop hung-up an invalid value (256)
in skipAdjacentParams2 sample data.

New code allowing for sqlite downloaded from git.

Has currently reached skipAdjacentParams1 on round 1224.
continuing.

27/05/2025
Trial running on windows laptop is at round 876
doing modulo first param 6. The seed entity programs
have been:
    sampleOutGreaterThanSampleIn
    seriesOfSeries

Have allowed for a sqlite database on the development
system, which appears to run quite a bit faster,
especially noticeable in parallel processing mode.

25/05/2025
The trial to complete the sampleOutGreaterThanSampleIn
rule ran for 607 rounds and reached 21.4/24

Inserted seed for sampleOutGreaterThanSampleIn.
Was stuck on sampleInMinusSampleOut, but this
was due to a bug in the rule. When fixed, this
completed in 2 rounds.

24/04/2025
The code now includes the sampleInMinusSampleOut rule.
The trial for the sampleOutGreaterThanSampleIn rule
completed after about 330 rounds, however, it
involved no comparison operation, simply producing
a sequence of 1's and 0's that matched the output
requirements. So restarting the trial with a preference
to include the CMP A, B op.

23/04/2025
Got the sample reading rule sampleOutGreaterThanSampleIn
working satisfactorily with two samples.

On the windows laptop, seeded the multiplyAdjacentParams
program after several days processing. Hit bug with
divideAdjacent params.

Started the trial from scratch on the Windows laptop,
including the sampleOutGreaterThanSampleIn rule.

22/04/2025
Added the sample out greater than sample in rule. Ran
short trial, but the code produced was simply a procedure
for outputting the pattern of 0 and 1 at random.

Will add a refinement to the rule to check for LDSI and
LDSO statements.

20/04/2025
Trial reached 19.4/24 after two days of processing
on sortParams. Introduced the seed program.
addAjacentParams was then completed quite quickly.
subtractAdjacentParams completed rather suddenly
after 320 rounds, having been stuck at 14/22 for
a long time.

The conclusion from this is that it can be worth
waiting for upto about 400 rounds for a solution.
This is currently about 15 hours.

Had introduced the helper rules 
    outputsDifferentToInputs
    sumOfOutputs
    outputStandardDeviation

18/04/2025
Trial at sortTriplets has taken 518 rounds
to reach 19.7/28
Provided the seed program to complete this.

17/04/2025
Removed the set clearance
    eliminateDuplicateOuptuts
operation, as this seemed counter-productive.
Trial for greaterThan adjacent then completed in 
about 50 rounds.

16/04/2025
Inserted the seed program
    greaterOfAdjacent params
Which failed to reaced target after 800 rounds.

15/04/2025
Trial took 400 rounds to complete duplicate params
this time, for some reason. It has now been on
greater of adjacent params for 400 rounds, reaching
a score of 13.5/18
It is not yet clear why these should have taken
so long this time, although the extended probability
field due to the LDSI and LDSO instructions may
be the main reason.

13/04/2025
Trial continues on round 673.
Seed insertions have been:
    outputSeriesOfSeries
    moduloFirstParam
    divideFirstParam

current rule is duplicateParams

11/04/2025
Reintroduced the serial processing mode, slightly faster on the
windows laptop, slower on the Linux system.

Trial now includes the greater of three rule and the sort triplets 
rule. Will add seed as required.

10/04/2025
The sortParams rule reached a score of only 11 after a day'S
processing. Added the rule sortTriplets as a step.

Added the instructions LDSI and LDSO, to allow the entities
access to sample data input and output. The aim here is to
allow the entities the possibility of evolving intelligent/
responsive code.

Started a new trial from scratch with a cleared database.

09/04/2025
Parallel Processing completed, no speed gain on the laptops,
but ready for the use of a multi-core processing unit.

The seed code for paramsOps contained an error, but this was
corrected by the system after about 100 rounds.

Pre-existing entity solutions were utilised efficiently.

The trial continues on Param Operations 7

31/03/2025
Added seed to continuing trial, operation
    multiplyAdjacentParamOp

29/03/2025
The current trial has had to have seed for:
    outputSeriesOfSeries
    moduloFirstParam
    divideByFirstParam
    greaterOfAdjacentParams
    subtractAdjacentParams
    multiplyAdjacentParams

26/03/2025

The trial using fragments completed as far as moduloFirstParam6
with a single manual insert (outputSeriesOfSeries).

Have included the rule outputScoresEqual to encourage the
use of inputs across input data trials. Current trial has
reached 24/32 at rule outputSeriesOfSeries3 with no manual
inserts by round 240.

Consider increasing the max score for outputScoresEqual
(currently 1).

24/03/2025

Added a feature of searching the seed rule programs
for fragments in common with the rule just completed.
These are then randomly incorporated into entity
breeds by monoclonalInsBreed.

Started the trial from scratch (at first rule) with
this feature added. Have used one seed program
so far (seriesOfseries), and the system is currently
working on multiply by first param 2 (round 126).

Note that is is sticking on variants that satisfy 
half of the problem set, but not both. It would
be worth pondering solutions to this form of
deadlock. (Perhaps extra points for scoring equally
in each trial execution cycle(input block)).

19/03/2025

paramOperations - divide reached 12/16 after about
18 hours.

Restarted the trials from scratch using the seed
rules.

18/03/2025
Readded output difference checking, with refinement
of calculating the optimum from predetermined outputs.

In the scoring for rules am now taking account of consecutive
correct values from the start of the output to encourage
serial processing.

Trial on paramOperations - modulo now running.
Seed for the modulo inserted. So trial proceeded
to paramOperations - divide.

15/03/2025
The subtract paramOperations completed, but the
system got stuck on the multiply paramOperations
rule, so am hand crafting that. Will also introduce
a divide paramOperations rule and a modulo paramOperations
rule.

The system reached a score of 11.4/15 on the modulo
paramOperations rule. It is worth noting that the
solution it evolved was a primarily blind pattern
of numbers applied to both instances of the input
data. So it is worth re-introducing the outputDifferent
rule, to ensure that experimentation with the inputs
takes place.

14/03/2025
The system got stuck on the add paramOperations
so have created the seed code for this. New trial
running.

The system is now working on the subtract paramOperations.
This scored 10.9/15 after 140 rounds, so introduced the
seed program and continued trial.

13/03/2025
The trial of paramOperations rule got stuck at
24/45 after 1 day's processing. So splitting
the problem into smaller rules.

Still stuck on simplfied rules, so provide further
simplicity by add in the rules as individual examples.

The = operation completed naturally

12/03/2025
Trials have worked through all the rules upto
paramOperations which is currently running at 45%
of the score. This rule probably needs breaking
down into stages.

Have supplied 4 hand-crafted solutions out of a total
of 36 rules.


08/03/2025

System stuck on divideByFirstParam - so will write
the seed for that and allow the system to proceed.

The new envisioned goal is to provide code that the
system gets stuck on and build-up a library of auto
and human generated solutions that can be merged,
mutated and permuted by the system to provide new 
solutions.

It is worth noting that the divideByFirstParam
rule reached a score of 15/20 achieving division
by 2 on the first half od the problem in 577 rounds,
proving that it was still capable of improving over
time, but not within acceptable time frames on these
resources. So we can see that we are engaged in either
reducing the size of the probability field, or of
speeding processing.

07/03/2025
Removed the instructionCount rule from circulation.
Results achieved much sooner in terms of rounds, 
including seriesOfSeries3. Got stuck on modulo [5,6]
rule.

The new policy is to provide a seed program for every
rule that gets stuck at 140 to 160 rounds. These
seed programs can then contribute to the search for
solutions in other cases.

For the next trial modified the instructionCount rule
and re-included it. Provided a seed for modulo rules.

06/03/2025
Introduced more fragments and ran a trial of seriesOfSeries3
on its own, to overcome the problem of seed contribuants
causing early entrapment. Score is currently 38/52 with
scattered output after 111 rounds. Leave this to reach 180
rounds.

Suggestion is to modify the other series so that they do
not have a single value for a parameter, this should help
to prevent "ghost" values and repetitions of code appearing.
We could also have a rule to exclude CALL which was used
to create a list of repeated block calls, in preference to
controlled loops.

The trial excluding CALL statements reached 36.5/52 after
212 rounds on seriesofSeries1, achieving 2 series out of 5.

Have now included a futher fragment that represents loops
more thoroughly. This is currently under trial. This made
no significant difference.

As a further approach we can write a script as seed and 
insert when the relevant rule is reached. We can justify
this in terms of the projects processing goals only, in
the building-up of example seed code to be used via
permutation and combination in other situations.

This approach has cleared the rules as far as part of
the modulo rules. Will supply the modulo solution and
insert it, as for seriesOfSeries.



05/03/2025
The system got stuck on the rule seriesOfSeries3 at 33/44 
after 420 rounds. The code consists of a stochastic unconditional
loop which makes a single reference to the input parameters

This suggests that it would be useful to reward the number of
parameter reads in the first block of code. So we include the
rule numInputReads in the ruleset for the next trial.

This trial reached 42/52 after 200 rounds. So have reduced the
range for the numInputReads to the first 16 instructions, rather
than 42.

Next consider the number of JRNZ instructions in the first
section of code.

04/03/2025
The score on seriesOfSeries3 after 540 rounds is 34
out of 44, on the windows PC.

The score on seriesOfSeries1 after 160 rounds is 31
out of 44 after 160 rounds, on the linux PC.

Will leave for a few more hours to see if there is
any improvement, whilst I attempt a rethink of the
templates and fragments approach.

One possibility is to reward the presence of certain
instructions in the primary execution group (0 to 30).
Discussion in WorkedExamples.

Decision is to try more small code fragments such as
    LDI A, (C)
    INC C
    ST (MEM), A

Using upto 5 instructions.

Having added this feature, the system reached 32/44
in 180 rounds, so this was not an improvement.

Next-up increase the highIP for this rule to 42 to
allow more scope for variation.


03/03/2025
The trial on the windows laptop reached 37 from 44
after 400 rounds on seriesOfSeries3.

Have now set the number of best sets back to 64
as allows more depth of searching in a given time.

02/03/2025
Ran trial with seriesOfSeries1 parameters:
[2,16,5], [5,16,5], [7,16,5], [10,16,5]

This achieved the target distributions of outputs, but
not the instruction count score, because it had evolved
the output result, rather than efficiencies of code.
We can try weighing more in favour of efficiencies of
code instructionCount. We can also include the highestIP
rule to favour compact code.

Having included the highestIP at 28. The system scored
31.1 out of 44 after 165 rounds.

What would be good to determine is whether this is a 
logical/probabilistic trap or whether it is a statistical
anomaly.

On the next trial the number of best sets is increased
from 48 to 64, the clearance pass from 15 to 20 and
the number of process main loops decreased from 10
to 5.

Using this combination, the system reached 37 out of 44
in 72 rounds. The first seriesOfSeries rule was completed
on round 95, after 75 rounds.

The system got suck on seriesOfSeries3, scoring 37 out of
44 after about 400 rounds. It was stuck on the second parameter
as 4.

Have modified the first parameter to break-up patterns
established by the prior run.
    3: [3,3,5], [6,5,4], [9,4,4], [11,4,5]

The basic problem is to get it to use a loop based on
the second parameter. It may be better to use more
widely spaced values for the second parameter,
try:
    3: [3,12,5], [6,4,4], [9,7,4], [11,3,5]



01/03/2025

Even with the insertion of another seriesOfSeries rule
the second did not complete in 160 rounds.

The problems have the parameters
1: [2,4,5], [5,4,4], [7,4,4], [10,4,5]
2: [2,3,5], [5,5,4], [7,4,4], [10,4,5]

The first parameter refers to the series interval,
the second, the length of the series and the third
the number of times the series is repeated.

The first example (where the length of the series is the same) 
is solved within 10 rounds.

So the problem is getting the system to use the second parameter
to control a loop rather than guessing.

The main of the difficulty for adjusting is that the code uses
repeat sections of code rather than loops. So if for example,
we make the first seriesOfSeries 8 long rather than four, 
we have a higher chance of a loop being selected.

28/02/2025

Added the rules outputSeries and outputSeriesOfSeries, which
take their cue from the input parameters.

Initial trial completed outputSeries in 4 rounds, but was
still stuck on outputSeriesOfSeries after 140 rounds.

Loosely, the things to consider are the transference of
code learned for other problems and the complexity of
a transform/innovation.

Add another outputSeriesOfSeries rule with the repeat
parameter set the same.

The new outputSeriesOfSeries rule allows the system to
reach score 21 in 40 rounds - faster than being without.
But it remains to be seen whether it will complete
the task in satisfactory time. Little progress at
70 rounds.

27/02/2025

Introduced code templates and fragments to the instruction
set module. Part of the argument for this is that such combinations
of code might arise by chance.

Ran a trial with the templates and fragments, no noticeable
difference to outcomes.

The system has been stuck for a very protracted time on
module (5,6) and this trial is now abandonned.

The problem is to create rules in which the adaptive steps
from on to another are sufficiently probabilistically
small.

Am adding the rules outputSeries and outputSeriesOfSeries 
to aid the development of loops as seed for other problems.

26/02/2025

Re-introducing the instruction count rule worked for
the same set of rules as worked previously. But the
system still gets stuck on the combined modulo (5,6).

So the challenge here is to come-up with a more effective
way to combine prior solutions. This is discussed in the
WorkedExamples document.

25/02/2025
The system got stuck on modulo (5,10), so have started
a new trial with the essential numbers (2,3,4,5,6,7) as
individual rules. If these work they will lead on to
a combined trial.

These things bring to mind one of the fundamental issues
of what we are trying to accomplish - which is whether
to tackle a problem as a direct mapping relationship
or whether to apply an algorithmic function.

Note also that algorithmic functions may also be sets
of conditional mapping relationships.

After a trial of 60 rounds, the modulo combination (5,6)
reached a score 9.4/12

Have re-introduced the Instruction Counter score to
favour shorter (ie: algorithmic type) solutions.

24/02/2025

This time the system got stuck on divideBy (3,4).
this is basically because of the difference between
the divide methods for 3 and 4 using the SR A 
instruction. If we remove the SR A and SL A instructions,
likely it will use SUB A, B for the general method.

23/02/2025

divideByFirstParam 3 got stuck for about 400 rounds with
the first params being (3, 6).

Have now introduced a prior rule with params (4, 6) -
ie: both even, one being a power of 2.

This rule reached 11.3 after 238 rounds - still too
long to be practical and subject to random number
inserts rather than algorithmic products.

If we use say 4 input parameter blocks rather than
2 we reduce the chance of the system using ghost
values rather than reading the first parameter,
furthermore, we are more likely to get a general
result for the operation rather than a program
specialised for a particular number.

A likely problem with this approach is that it
would be trying to solve too much in a single
pass.

Since the appearance of a ghost parameter provides
a partial solution, it is still worth generating.
So perhaps the two approaches can be combined,
using two parameter blocks of the first few rules
and then more on the subsequent. This would allow
the individual, partial solutions, to be merged
into a single general solution.

22/02/2025

Having introduced the additional multiplyByFirstParam rule,
the trial completed the multiply rules by round 64. It
then got stuck for over 250 rounds on the divide rule, so
have now introduced additional divideByFirstParam rules
(2,4; 3,6).

Restore selected rule seed works correctly.

Divide by first param (2,4) was completed in 3 rounds.

The second divide by rule was at score 7.5 after 80 rounds.
Introducing another rule (2, 3).


20/02/2025

The trial got stuck on second multiplyByFirstParam rule
(3 and 9) for more than 300 rounds. Have introduced an 
oddAndEvenParams rule, to see if this helps. Also introduced
an additional multiply rule (6 and 5).

19/02/2025

The trial on the windows computer got stuck at score 9.75
for rule paramsCompareN (12) after 229 rounds, so this
run was abandonned. All preceding rules were completed
by round 160.

On the current set-up, it looks as though runs of several
days would be necessary.

Have removed the rules with "ghost" parameters and replaced
them with rules that use the first input parameter.

Extended the clearance pass cycle to 15 to allow novel
solutions to catch-up with current ones.

This trial is commenced at midday today.

It took until round 20 to complete the rule addFirstParam.

However it took only 2 rounds to complete the subsequent 
subtractFirstParam

Halted the trial at round 124 having not completed the 
multiplyByFirstParam rule. So inserted another rule
for multiplication (2 and 4, 3 and 9) to divide up the task.

New trial started.


18/02/2025

The paramsGreaterThanN rule took 11 rounds to complete
The paramsCompareN rule took 131 rounds to complete
However, the paramsTimesN (6) rule had only got to
score 6.8 after 100 rounds, so some new factor has come 
into play here.

This last problem may be due to the overuse of the
seed-rule. The frequency of this has been adjusted 
downward for the next trial.

The trial got stuck on paramsTimes(N) 22 for over
100 rounds. This is a substantial downgrade from
earlier trials and may be due to the order of rules,
the lowering of the seed rule trials or the addition
of the SL A and SR A instructions.

Try increasing the seed rule frequency and moving the
comparison rules after the times rules.

The paramsTimesN (2) rule completed in two rounds
using the SL A instruction.

However, this has made it more difficult for the
paramsTimesN (6) rule to learn from the previous
rule, and this has taken 36 Rounds to reach score
6.5

Whether to introduce a paramsTimesN (3) rule as
an intermediary step?

Whether to supply certain parameters via special
instructions - or better to rely on the existing
parameter block?

Use add/minus/subtract/times/divide first param rather
than "ghosting" the parameter.

There was no speed advantage to adding a ghost value
preceeding the add first param rule.

17/02/2025

Having set the rule pass score to 9.9/10 we find that
the paramsGreaterThanN rule takes more than 220 rounds.
The previous trial did not include the output case in which
a === b, since the score was 9.5/10.

However, since the output result requires 8 zeroes on trial A
and 5 on trial B, this clashes with the valuesOutSet rule, so
that the maximum score attainable on the correct result is
9.8437

We can fix this by having 1 = <, 2 = =, 3 = > and thereby
avoiding zeroes on the output. 

The output code required is something like:

ie:
LD A, IMM 2
LD B, IMM 112 (or greater)
// Output 2's
STO (C), A
INC C
DEC B
JRNZ 0xFD
LD C, IMM 0
LD B, IMM 12
// Loop
PUSH A
LD A, IMM 16
LDI A, (C)
CMP A, B
JRC       // 12 > A
JRZ 4     // A === 12
LD A, IMM 3 // A > 12
STO (C), A
JR 8   // Next
// A === 12
LD A, IMM 2 // A === 12
STO (C), A
JR  3 // Next
// A < 12
LD A, IMM 1
STO (C), A
// Next
INC C
POP A
DEC A
JR NZ E9 // Loop
RETF

Points Arising

As a general rule the required output data should not have
more than 2 or 3 zeroes.

Where the number of output values is small, the random output
of numbers should not mask the logic required so the minimum
number of same outputs in such samples should be about four or
five and these should be scattered through the data so that they
are best elucidated by logic.

In the case of the paramsGreaterThanN function, it is suggested
that the parameter inputs should be set to reflect these things.

For the next trial, I have supplied the parameters to the 
paramsGreaterThanN function directly, this time with five
or six inputs scattered, which should provide the range outputs.
I have also added the SL A and SR A instructions.

Further Trials

The trail with the original data was still stuck at score 9
after 137 rounds.

The trial with the data reached score 9.4367 by 61 rounds.
So we have proven the general principle that sample input data
is significant.

The next attempt is to split the rule into two - first
with paramsGreaterThanN then paramsCompareN

This trial took 11 rounds to complete the rule paramsGreaterThanN

As general rule it is better from a practical point view not
to allow testing to go beyond 45 - 60 rounds for an individual rule.
If a rule reaches this without passing, it would be better to
rework it in some way.


16/02/2025

Latest trial with LD A, R, LD A, S removed in response
to unpredictable results with paramsGreaterThanN.
Trial without these is stuck on the rule after 71
rounds. So moving the rule back to the position after
paramsMinusN, as subtract is more likely to be useful
as a step.

Have decided to leave the idea of the faster computer
until finances are more settled. Better to focus on
rules that can proceed in reasonable time and to consider
ways in which the output from these can be combined/re-utilised.

The paramsGreaterThanN rule was completed after 87 rounds
when following paramsPlusN (6).

By positioning the paramsGreaterThanN rule after paramsMinusN,
the rule was completed by round 27.

Restarted a trial with all the current features - intention
is to leave it to run for up to three days, before doing
further development work with new rules.

Need end of job functionality. (Completion of all rules)

11/02/2025

It is now clear from the proceedings that time scales
required to pass each rule are too large using this
existing technology (laptops). Options are: 

1) To obtain a quad computer and parallelise the main
processing loop.

2) To rewrite the backend in PHP and use my existing server, using
parallel threads.

The first solution requires time to obtain the finance.

09/02/2025

The new rules and instructions were added. The resultant
times were as follows:

Rule      | Rule                                 | Round
Sequence  |                                      |
0         | outputMatchesInitialParams           | 1
1         | paramsPlusN (3)                      | 5
2         | paramsPlusN (6)                      | 6
3         | paramsMinusN (3)                     | 8
4         | paramsMinusN (6)                     | 12
5         | paramsTimesN (2)                     | 13
6         | paramsTimesN (6)                     | 14
7         | addFirstParam                        | 20
8         | addSecondParam                       | 28
9         | duplicateParams                      | 127
10        | skipAdjacentParams1                  | 175
11        | skipAdjacentParams2                  | >190

Note the large gap between addSecondParam and duplicate params
and that this has been performed much more quickly previously.
We cannot be certain that this is not just a statistical quirk.
But we can investigate the code. See WorkedExamples.txt.

Fixed error in paramsTimesN, adjusted scoring by removing exponent
since we are doing one rule at a time. New trial started.

Suggest changing the number of rounds in a clearance pass to
10 as standard, rather than letting it grow longer and longer
as more rounds pass, since we are dealing with longer trials.




08/02/2025

Changed the length of the output field data to 16 bytes
rather than 8. Replaced paramsPlus/MinusThree by 
paramsPlus/MinusSix to obviate the appearance of
INC A, INC A, INC A rather than ADD A,B. However we
note that in today's trial the system used the crafty
trick of substracting 250.

The addAdjacentParams rule remains problematic so some
form of intermediate rule is required.

Having observed that paramsTimesTwo now takes at least
70 rounds, it seems necessary to reintroduce paramsPlusThree
and paramsMinusThree

So the following rules are to be introduced / adapted:
    paramsPlusN - where N is supplied in the rule
    paramsMinusN - where N is supplied in the rule
    paramsTimesN - where N is supplied in the rule

In addition, the instruction set will be modified to
include the instructions JRNZ and JRNC

Note that in fact paramsTimesTwo lacked the qualifier & 255,
so these results were invalid.

07/02/2025

Having added the rule greaterThanAdjacentParam we find
that although this rule is completed (after 72 rounds),
the code produced matches by rescrambling the inputs,
not by using the CMP or SUB operations. This demonstrates
a basic weakness in the design. It could be overcome
by using 16 bytes of output data rather than 8, making
coincidences of arrangement between the two input datasets
less likely. This kind of effect could be defined as
"Right answer, wrong method".

06/02/2025

Having added rules add first param and duplicate params
 
Overnight Run

Rule      | Rule                                 | Round
Sequence  |                                      |
0         | outputMatchesInitialParams           | 1
1         | paramsPlusThree                      | 10
2         | paramsMinusThree                     | 12
3         | paramsTimesTwo                       | 14
4         | addFirstParam                        | 15
5         | duplicateParams                      | 19
6         | skipAdjacentParams1                  | 63
7         | skipAdjacentParams2                  | 94
8         | swapAdjacentParams                   | 97
9         | addAdjacentParams - not completed    | >271

Added the rule addSecondParam to see if this would accelerate
the completion of rule 9.

05/02/2025

Introduced duplicate and transpose mutations to monoclonal
breeds.

The following were obtained on an overnight run:

Rule      | Rule                                 | Round
Sequence  |                                      |
0         | outputMatchesInitialParams           | 1
1         | paramsPlusThree                      | 5
2         | paramsMinusThree                     | 18
3         | paramsTimesTwo                       | 20
4         | skipAdjacentParams1                  | 27
5         | skipAdjacentParams2                  | 104
6         | swapAdjacentParams                   | 107
7         | addAdjacentParams - not completed    | >149

Suggested changes:
Add the following Rules:
    duplicateParams
    paramsPlusFirstParam

Include an interbreedInsMerge breed method to favour combinations
of proven code.                 

04/02/2025
The main system had not completed rule sequence num 4 (skip
adjacent params) by 160 rounds.

The windows system had not completed rule 6 by 340 rounds -
this rule has yet to be completed.

03/02/2025

Got to rule 6 (addAjacentParams) after 125 rounds, completing
the skipAdjacentParams and swapAdjacentParams rules. The question
is whether the completion of these two rules adds to the speed
of completing rule 6.

Note that the completion time of rules is quite variable from run to
run.

On the trial run, the system reached rule 4 (skipAdjacentParams) in just
26 rounds, showing just how wide the variance in time taken is.
 
02/02/2025

Added the rules addAdjacentParams and subtractAdjacentParams
to try to ease the passage to multiplyParamsByEachOther.

Currently the rate of progress is about one rule every 20
rounds. Although after a couple of trials, we find that there
is substantial variation in the amount of time taken to reach rule
4 (addAdjacentParams).

At rule 4, the system gets stuck, so this still requires an
intermediate step. Consider swapping around the adjacent 
parameters, which involves fewer instructions.

01/02/2025

When the output address was set to start at 0 for each rule
results were much more rapid, although rule 3 (multiply params
by 2) had not been solved after 100 rounds.

Changed the input block for multiply params by 2, to 0. rule solved
by round 5, using lower threshold.

Now the system sticks at rule sequence 4 (multiply parameters
by each other) - since this is a complex loop, it would be better
to include an intermediate rule such as add parameters to
each other, or subtract parameters from each other or both.

31/01/2025

Established the selection of only one rule at a time using
the result of one completion as the seed for the next.

Trial on windows computer switched to the second rule after
14 rounds. The second rule had still not been solved after
150 rounds.

Since the rules are operated one by one, it may well be 
better to use the same output addresses for each rule, as
this would potentially save a few instruction modifications
on the entities.


29/01/2025
After 180 rounds, the main computer scored about 28 points
out of a possible 34, with a few hits on the second rule.
This was achieved with a loop of 61 bytes, which put outputs
into two sections, the first extending into the first rule
area and the second starting at the second rule area.

Set the score exponent to 1.01 on the main computer. Trial
reached the second rule in < 21 rounds.

Terminated the trial on the windows system as more or less
frozen performance after 180 rounds. Many scores the same.
Next change suggested - eliminate incidences of duplicate
scores, even if they are not the best.

In no case has the progress on the second rule been significant.
In order to try to overcome this, we can reduce the threshold
for the second rule to 0.8, rather than 0.9, to allow for more
diverse solutions.

With the threshold set to 0.8 the second rule began at 7 rounds.
Allowing for the threshold of resistance to change being set
to 1.01, we may see an improvement in progress on rule 2. But
whether this is at the expense of the quality of solutions in
rule 1 we shall see. After 57 rounds the highest score was
still only 26, so there must be some probabilistic obstacle
to further progress. After 85 rounds, the situation was the same.

Restart the trial with both rules from the start, to see how much 
difference that makes in about 40 or 50 rounds. At 34 rounds the
scores reached 24 points, so dealing with two rules is at least
exponentially slower than dealing with one, this makes sense when
we consider the additional combinations of instructions required.

If we save the successful result of the first trial and then restart
to do the second, then this should in theory take the same amount of
time as the first. Would such saved solutions be useful and how could
they be made further use of, assuming we were aiming at an escalator
of capabilities?

Let us adapt the program so that when it completes a problem, it saves
the solution, then leaves that problem to begin another, using the
foregoing as the seed. Would this be better than starting from scratch
or worse? It is worth a trial. Because the seed will effectively score
zero on the new problem, how do we introduce it?

We can use the seed program rather than random code in the breeding
stage of each entity program, but still retain the other breeding
methods (monoclonalByte etc.).  


28/01/2025

Set-up trial excluding the code combination rules.

This took 71 or 72 rounds to reach the 90% mark for the 
scoring on the first rule (valuesOutMatchInitialParams)

In parallel to this is a trial to make the system slightly
less conservative, setting the score exponent to 1.5
instead of 2. This took 32 rounds to achieve the first result.

Restarted the trial with an exponent of 1.2 on the main computer
and 1.5 on the faster, windows computer.

With the exponent set to 1.2, the system transitioned to the
second rule (paramsPlusThree) in less than 27 rounds. However
it had made little progress on the second rule after 60 rounds.

After less then 117 rounds, the windows computer began the
second rule.


27/01/2025
The preceding day's results prove that as rules are added,
earlier rule results decay as the new conformancies rise,
so that there is an averaging-out process.

I have re-added exponential scoring, so that the "cost"
of disinvesting in a solution is higher than a gain in
another solution. Early testing seems to indicate that
general improvements proceed. Yet to see transition to
a second rule.

Next is to use best score thresholds to mark the introduction
of each new rule to the entities. But it is possible that the
addition of the disinvestment cost is sufficient to permit
timed introductions to work effectively.

Having added in rules for code combinations, the results
were extremely poor. 60,000,000 trials and only a score
of 37 out of 42 for the first challenge 
(valuesOutMatchInitialParams).

The system performed better without these rules.

26/01/2025
Reduced the cross-set breeding to 0.001 to increase variety,
but this still moves toward the general solution of a list
of series preceded by a match of input params, at which point
the system sticks.

The basic problem is that the development of programming solutions 
is not strictly an incremental, step-wise system. Reason uses manoeuvres
to get to arrangements of code, not chance insertions, replacements
and deletions of code. So there is a layer of logic missing
in the approach. Bearing this in mind, we will pause to reflect
and to ponder how the missing layer might be defined and filled.

Another way of saying this is that gradations are fundamental to
evolution. Assemblages (such as code or DNA) are necessary for
the preservation and conveyance of state in the system.

Revisited the idea of using single rules at a time. This time
allowing a single rule, to sample how long it might take to achieve
a reasonable result. Used the rule valuesOutMatchInitialParams,
with the background rules initialParamsPreserved, valuesOutSet
and valuesOutDifferent. This took 26 rounds to achieve 7.5 out 8.

Then added in the rule paramsPlusThree to begin at round 27.
At round 53, the best result was almost a complete set of the
original problem plus three of the newly added rule. 

The results work out best if the previous score is close to its
threshold, so the next adaptation is to introduce each new rule
as the threshold is approached (max - 1?) and to perform them
in the required order.


25/01/2025
Ran two attempts in parallel, with clearance pass 5 on one and
10 on the other. Similar results.

Now trying reduced cross-set breeding (0.001) to attempt to
diversify trial attempts.

Next objective - study the probabilities of progressive code
variations that might lead to improved results.

24/01/2025
Have adjusted the byte scoring to score zero for a hit and 255 for
a miss. Had an interesting result where I had changed the scoring
to give an idea of proximity to the correct result. The system used
this as a cheat to obtain the correct result!

Currently, I observe that what we are trying to achieve is to pluck 
the required results from a probability field, where we are uncertain
of the scale of the probabilities involved and therefore do not know
how much processing time is required.

From this standpoint it makes sense to put more effort into examining
probabilities, rather than measuring it empirically, which is what the
trials involve.

From the cheat result, we note that the system rapidly evolved a method
involving about 8 instructions, for solving scores in each problem
space. So we know empirically that we can achieve optimal solutions
that involve 8 instructions.

The trials thus far have proved that the system tends to evolve one
rational solution loop (transfer of input to output) and then a statistical
loop which scatters random numbers to the other problem spaces, some
of which incidentally score in those spaces. It does not yet evolve 
algorithms that are effective on the problem spaces.

21/01/2025
After about 30 million trials, the system tends to evolve two loops
which spread series through the output, with random score hits in
the output areas. There is no sign of algorithms to match specific
requirements from the inputs to the outputs.

The two loops tend to be of about 12 or 13 bytes in length (10 or 11
instructions). Also included is a termination condition in which 
multiple PUSH operations eventually break the end of the loop so
the program terminates in a string of NOOP operations.

As far as the system "works" it can be said to demonstrate increasing
sophistication. As far as finding specific solutions in finite time
we observe that it is not a practical solution.

So the next stage suggested is to increase the number of problems
set in the input space (since we have about 128 bytes remaining)
and allow the system to "explore" this space, coming-up with whatever
approaches it may evolve over a period of 10 to 20 days, if this
proves practical or desirable.

The things to watch-out for include getting trapped in particular 
solutions or whether the system continues to maintain sufficient
diversity to make steady score progress (albeit slow).

20/01/2025
The system quite rapidly resolves to a single solution - suggested
measures:

Increase the number of best sets to 48.

Decrease the frequency of cross-set breeding.

Increase the period between pass clearances.

Reaches 61 out of 146(max) over 60 million trials.


19/01/2025
Added score for reverse jump loops to encourage multiple score space
solutions.

Added routine to remove duplicate scores in the clearance pass.

After four hours have results of 57 versus 146 (max) just over
1/3. Will leave trial for about 18 or 20 hours.

Consider checking whether the loop back code is actually used as
well.

18/01/2025
Tried exponential scoring to see if it would produce specialisations,
instead no hits were scored at all against rules other than series,
different and params match.

Consider scores overlaying a single section of output.

16/01/2025
Introduced breeding from sections of code marked as used.

Flattened the scoring

Checked out simple seeding

Trial still produces scores of between a third and a half
after 20 million trials.

It is possible that seeding combined with the flagged
blocks interbreeding will improve matters. This is to
be the next trial. Accelerates development for a little
while, but soon hits the same plateau.

Reduce the the scores for the output only rules.

13/01/2025
Introduced staged rules

Introduced byte level mutations for monoclonal breeding as well as
instruction level.

Run to test byte level mutation underway. Staged rules made no appreciable
improvement over earlier attempts in a 10 hour, 16 million trial run.

The difficulty in the development of the entities remains the issue of
restricted probability pathways and the sheer fact of very low probabilities
of useful code arising.

Next stage, further the development of seed code/templates.

09/01/2025

Rulesets rearranged and added params -3. Increased number
of best sets to 32. 

Score still tends to settle at 1/3 or just below, scatterings
of random numbers and series.

Suggestions for work:

Localised interset breeding.

Paginated long range memory.
    256 byte pages referenced by 
        LDF A, (DC)
        LDF A, (MEM)
        STF (DC), A 
        STF (MEM), A 
        CFAR
        CFSM
        Additional reg D for 16 bit addresses

05/01/2025
All of the changes suggested were made, but the app still
plateaus at a score of about 1/3 of the maximum, presumably
because optima found at this level, do not provide a reasonably
high probability of finding an improvement. So we move back
to analysis to see what improvements might be made.

see WorkedExamples.txt

25/12/2024
Introduced a set of new instructions for the B and C registers.
Changed the number of best sets to 24 with just 40 entities in
each to overcome traps a bit better.
Increased the maximum instruction execution count to 2000 from 1000
to see whether the increased diversity would help.

Introduce a TSTO instruction which returns a 0-255 score in the A reg
for the last output value.

Consider introducing a rule for the adding together of adjacent
parameter inputs.

Consider including key words/symbols in the input data with examples,
ie: + a b, - a b, * a b, / a b
 
Meanwhile consider better strategies for code grouping.

13/12/2024
Tried increasing the number of best sets from 4 to 8. No particular
gain, progress slower, set back to 4.

Fixed problem with the instruction set (missing break; statements).

Ran an overnight run of about 48,000,000 trials. Little progress.
Try including memory transfers using register relative addressing.
This increases the size of the instruction set, so need to rework
the calculations accordingly.

Included the instructions ST A, (C) etc, for indexed addressing.
Initial gains large, but there appears to be a problem with breeding
methods, as gains are extremely slow after about 5 or 10 minutes.

11/12/2024
Multiple best sets included. Separated input output memory into
separate blocks of 256 bytes and included the relevant instructions
in the instruction set.

Achieved a 100% trial in 9 hours (20,000,000 trials), but it is rarely 
repeatable.

A great deal seems to depend on the initial selections, so will extend
the period of random generation per best set to several cycles.

07/12/2024
Having included the placing the outputs and parameters in
separate memory chunks and allowing for fixed block interbreeding
the scores to about 50% of the max in 45 minutes.

The next trial is to have separate best sets that interbreed with
each other periodically.

06/12/2024
The alternate input parameters approach improves matters only
slightly, the primary issue is that local optima are identified
by the system by simply placing (random) numbers in the output
rather than by the use of probabilities. This is because the
output sample sizes are small (4) so the chances of the random
numbers being on target can be higher than that of sequencers.

To overcome this, we can separate the parameter and output blocks
into separate chunks of 256 bytes and use different instructions
to access each.

04/12/2024
Having run the procedure for 5 hours (about 45,000,000 trials) a 
mediocre result was attained mostly consisting of random insertion
of numbers in the output fields.

Since the aim is to provide general operative functions, we need a
procedure to encourage this.

So let's try alternating the input parameters and using the same
rule set. The scoring can be done for each parameters set.

31/11/2024

Having managed to get as far as sequences of numbers in the top scoring position,
I decided to see if I could get more variant results by dividing up the ruleset
examinations of the output values into sections. The initial results are not
particularly promising although I may be able to compensate with counter-prevailing
rulesets (particularly a negative score for values of output left the same).

An option to consider is multiple best sets to overcome the problem of the
system getting trapped in probability dips arising from initial choices.

We may be able to distinguish in our trials between current selection scenarios
and those arising from ruleset weightings. The issue is to try to limit the
range of possible trial parameters.

At the present time the system is sticking with values still set to zero
in the output areas, let us try the rule that something is better than
nothing. If this rule is weighted at 100, it emerges as the prevalent
and produces a series on the output. What is more, variety is maintained
amongst the best set.

So if we now try upping the rating for multiply by two slightly, we maintain
the instability.

So we juggle the weights accordingly.
