Worked Examples and Strategies

Contents
    Problem Space Background
    Ruleset Strategies
        General Approaches
        Possible Future Approaches
            Staged Introduction of Rules
            Allow What Evolves and Pick the Useful
            Selecting Marked Sections
        valuesSet
        valuesOutMatchInputParams

    AI Code - Example Sequences
    Toward Stepped Pathways
    Performance Notes

<h1>Problem Space Background
    Using the instruction set to date, we can consider the solution to
    the first three rules. When written by hand, this requires about 57
    bytes of code, arranged in a particular order. Since there are
    currently 56 possible instructions, the raw probability of this code
    56 ^ 57, an astronomical number. Even if we retain an instruction at
    each pass for this solution, we would have
        S = (x ^ (n + 1) - 1) / (x - 1)
        S = ((56 ^ 58) - 1) / 55

    Nevertheless, out of this probability space, "solutions" emerge. The
    wider we make our problem space (number of rules in ruleset), the greater 
    the chances of forms of "hit".

    If solutions typically consume 60 bytes, then the storage space of
    256 bytes provides for only 4 optimal solutions. This also explains
    why the system tends to go for scattered numbers and series rather
    than focusing on specific solutions. In effect, we are evolving an optimal
    number scattering solution, rather than specific solutions, although 
    specific solutions may arise incidentally.

    So, turning the issue on its head, we can allow the entities to explore
    the problem space(s) and seek to optimise the delivery times and incidence
    of "useful" solutions.

    Within this framework, we have to allow for the fact that only one or
    two specific solutions are likely to arise, along with the general solution
    in the 256 byte space. We can solve this in two ways. Either by extending
    the size of the memory space for each entity (which further widens the 
    probability space) or by expanding the number of entities so that they form
    separate territories, which may specialise in different problems.

    We note that number scattering is likely to be a very different solution
    to specific solutions, other than in the deployment of loops for series.
    

    
<h1>Ruleset Strategies

<h2>General Approaches
    Step 1) Put values in the output
    Step 2) Read the input and place in the output
    Step 3) Read the input and put a value at the specified memory location
    Step 4) Put a series in the output
    Step 6) Read the input and modify in a simple way (eg: +3)
    Step 6a) input -3
    Step 6b) input *2
    Step 6c) input /2
    Step 7) Cued inputs with parameters, ie = 100(addr) 10, + 5 6, * 2 7

    In practice even after 20,000,000 or so trials, the system
    devolves to distributing arrangements of random numbers and 
    series in a scatter through the output area. Although the 
    introduction of breeding ranges and a output difference test
    for each execution cycle has improved the rate of change.
    There is a marked absence of systematic manipulation of the
    inputs. This might be improved by balancing the input 
    instruction distribution in favour of LDI operations. Even
    direct transfer of inputs to the output fails when tied to
    a non-zero based output block.

<h3>Considerations for rule scoring
    On the one hand more valuable or lower pobability/higher complexity
    outputs should score more. However, this means that correct, lower
    scoring results may be overwritten by chance byte values having been
    set in the output. A possible solution to this is to add a bonus for
    a complete solution and to keep score weightings relatively flat.

<h2>Possible Future Approaches

<h3>Staged Introduction of Rules
    This would involve stepping through the rules after specific
    numbers of cycles. This may encourage more concentration on 
    specific solutions and help to establish the IPO habit.

    However code patterns may well degrade to random scatter as
    new rules are introduced.

    This approach was added, without significant improvement.
    Although a trial is now underway which shows some promise
    with the stages extended somewhat.

<h3>Allow What Evolves and Pick the Useful
    This approach modifies the user demands of the system, to
    one of producing interesting or useful code fragments and
    sections over an open-ended period of time.

    This approach would allow the opportunistic addition of rules
    to favour certain patterns of output, so that after a medium
    period of time, certain interesting effects would begin to
    arise.

    In this case the addition of rules to the system over time 
    should be allowed for.

    This may well require substantial development to facilitate 
    user intervention and observation.

<h3>Selecting Marked Sections

    A possible approach to heirarchical selection of code is
    to pick-out code sections that are actually used by the
    entity. As the instructions run, the code can be flagged
    at the instruction positions. Subsequently, the marked
    blocks can be extracted and combined to make a new entity.

    The main difficulty with this approach is deciding how best
    to combine and make use of the sections. One possibility
    is to wrap them in SM, RET instructions and call them
    from the head of the code. Another is simply to cross-breed
    with the flagged blocks and rely on mutations to merge
    the code together.

    This approach set-up and current trial seems to produce
    some improvements.

<h2>valuesSet
    Since the primary aim is to produce out, the first rule
    is valuesSet this checks each byte of the output to see
    if a non-zero value has been set. The score is a factor
    of 1 per byte set over the tested range.

    A typical sequence of entity code required to get the 
    maximum for this rule would be:

    INC A
    STO (C), A
    INC C
    JR [0xFD]

<h2>valuesOutMatchInputParams
    This is tested for in a specific block of 8 bytes and
    specific set of input parameters, so not only must the
    operating entity discover the necessary output, but also
    the specific inputs.

<h1>AI Code - Example Sequences

1) Sequence of numbers from output position 0
    INC A                           1/56
    STO (C), A                      1/56
    INC C                           1/56
    JR 0xFD (or lower)              1/(56 * (256 - (127 - 2)))

1A) Example from AI Code
    DEC B               B:255        B:1            B:254
    STO (C), A          O(0):0       O(255):0       O(2):255
    INC A               A:1          A:1            A:0
    INC A               A:2          A:2            A:1
    SWP A, C            A:0, C:2     A: 255:, C:2   A:2, C: 1
    SWP B, C            B:2, C:255   C:1, B:255     B:1, C:254
    JR 0x8E
 
<h1>Toward Stepped Pathways
Having tested the app as at 05/12/2025 - we find that code
entities plateau with a score of about 1/3 of the maximum
using a mixture of random number and series transfers to
output, but also a degree of reading from the input.

These scores were achieved after about 80 million trials
and scoring progress was very slow indeed at this point.

The most likely account for this is that further improvement
would require very low probability events in the breed/mutate
cycle.

Here, we consider stepped pathways, in which no progressive
step has a probability lower than a certain threshold.

So let us consider some sequences.

Firstly consider

LDI A, (C) // LD A from the input buffer
STO (C), A // ST A in the output buffer
INC C 
JR 0xFC // Jump relative back to start

Using the rule sets, this scores on valuesSet, outputFromInitialParams, outputMatchesInitialParams

<h1>Performance Notes
23/01/2025
Addition of convert ASCII numbers rule

Best Set Score: 57.7241 from 162
Loops: As previous, but also included a send conditional jump back which may activate
Elapsed Time: 9.2121
Number of Trials: 51,014,400

Best Set Score: 56.4711 from 162
Loops: 2 Loops, the first with a conditional branch which jumps to the second
Elapsed Time: 2.1539
Number of Trials: 12,550,400

22/01/2025
Add clearance of duplicated outputs

Best Set Score: 61.6447 from 154
Loops: 2 loops, both modified by themselves
Elapsed Time: 18.6437
Number of Trials: 85,017,600
Comments: Quite a bit faster improvement than the previous 30,000,000 trials.

Best Set Score: 59.8913
Loops: 2 Self-modifying loops
Elapsed Time: 11.5534
Number of Trials: 51,488,000
Comments: Note that it has taken 6 hours to gain 0.6 points.

Best Set Score: 59.2335 from 146
Loops: 3 self-modifying loops, bytes 0 - 47
Elapsed Time: 5.5057
Number of Trials: 21,740,800

20 - 22/01/2025
Best Set Score: 65.7074 from 146
Loops: 2
Loop Lengths: 12, 11
Elapsed Time: 2.25 Days
Number of Trials: 272,761,600
